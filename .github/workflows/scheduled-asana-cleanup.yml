---
# Scheduled Asana Task Cleanup Workflow
# Automatically completes tasks that meet predefined criteria
# Runs daily with safety checks and comprehensive reporting

name: Scheduled Asana Cleanup

on:
  schedule:
    # Run daily at 9 AM UTC (11 AM SAST)
    - cron: '0 9 * * *'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode - show what would be completed without actually completing'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      completion_criteria:
        description: 'Completion criteria filter'
        required: false
        default: 'overdue'
        type: choice
        options:
          - overdue
          - ready_tag
          - old_completed_subtasks
          - custom

jobs:
  scheduled-cleanup:
    runs-on: ubuntu-latest
    outputs:
      completed_count: ${{ steps.cleanup.outputs.completed_count }}
      skipped_count: ${{ steps.cleanup.outputs.skipped_count }}
      error_count: ${{ steps.cleanup.outputs.error_count }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          pip install asana requests python-dateutil

      - name: Scheduled Task Cleanup
        id: cleanup
        run: |
          cat > scheduled_cleanup.py << 'EOF'
          import asana
          import sys
          import os
          from datetime import datetime, timedelta
          from dateutil import parser
          import json

          def get_client():
              pat = os.getenv('ASANA_PAT')
              if not pat:
                  print("‚ùå ASANA_PAT not found")
                  return None
              return asana.Client.access_token(pat)

          def is_overdue_task(task):
              """Check if task is overdue"""
              if not task.get('due_date'):
                  return False

              due_date = parser.parse(task['due_date']).date()
              today = datetime.now().date()
              return due_date < today

          def has_ready_tag(task, client):
              """Check if task has 'ready-for-completion' tag"""
              try:
                  task_details = client.tasks.find_by_id(task['gid'], {"opt_fields": "tags.name"})
                  tags = [tag['name'].lower() for tag in task_details.get('tags', [])]
                  return any('ready' in tag or 'complete' in tag for tag in tags)
              except:
                  return False

          def has_completed_subtasks(task, client):
              """Check if task has all subtasks completed (indicating main task ready)"""
              try:
                  subtasks = list(client.tasks.subtasks(task['gid'], {"opt_fields": "completed"}))
                  if not subtasks:  # No subtasks
                      return False
                  return all(subtask['completed'] for subtask in subtasks)
              except:
                  return False

          def should_complete_task(task, criteria, client):
              """Determine if task should be completed based on criteria"""
              if task['completed']:
                  return False, "Already completed"

              if criteria == 'overdue':
                  if is_overdue_task(task):
                      return True, "Overdue task"
              elif criteria == 'ready_tag':
                  if has_ready_tag(task, client):
                      return True, "Has ready tag"
              elif criteria == 'old_completed_subtasks':
                  if has_completed_subtasks(task, client):
                      return True, "All subtasks completed"

              return False, "Does not meet criteria"

          def run_cleanup():
              dry_run = os.getenv('DRY_RUN', 'true').lower() == 'true'
              criteria = os.getenv('COMPLETION_CRITERIA', 'overdue')

              print(f"üîç Running {'DRY RUN' if dry_run else 'LIVE'} cleanup")
              print(f"üìã Criteria: {criteria}")
              print("=" * 60)

              client = get_client()
              if not client:
                  return False

              # Get user's workspaces
              workspaces = list(client.workspaces.find_all())
              if not workspaces:
                  print("‚ùå No workspaces found")
                  return False

              workspace_id = workspaces[0]['gid']
              print(f"üè¢ Workspace: {workspaces[0]['name']}")

              # Get user's tasks
              me = client.users.me()
              tasks = list(client.tasks.find_by_user(me['gid'], {
                  "workspace": workspace_id,
                  "opt_fields": "name,completed,due_date,projects.name,assignee.name",
                  "completed_since": "now"  # Only incomplete tasks
              }))

              print(f"üìä Found {len(tasks)} incomplete tasks")

              completed_count = 0
              skipped_count = 0
              error_count = 0

              completion_log = []

              for task in tasks:
                  should_complete, reason = should_complete_task(task, criteria, client)

                  project_names = [p['name'] for p in task.get('projects', [])]
                  project_info = f" (Projects: {', '.join(project_names)})" if project_names else ""

                  if should_complete:
                      if dry_run:
                          print(f"üîç WOULD COMPLETE: {task['name']}{project_info}")
                          print(f"   Reason: {reason}")
                          completion_log.append({
                              "task": task['name'],
                              "reason": reason,
                              "projects": project_names,
                              "action": "would_complete"
                          })
                          completed_count += 1
                      else:
                          try:
                              client.tasks.update(task['gid'], {'completed': True})
                              print(f"‚úÖ COMPLETED: {task['name']}{project_info}")
                              print(f"   Reason: {reason}")
                              completion_log.append({
                                  "task": task['name'],
                                  "reason": reason,
                                  "projects": project_names,
                                  "action": "completed"
                              })
                              completed_count += 1
                          except Exception as e:
                              print(f"‚ùå ERROR: {task['name']}{project_info}")
                              print(f"   Error: {str(e)}")
                              completion_log.append({
                                  "task": task['name'],
                                  "error": str(e),
                                  "projects": project_names,
                                  "action": "error"
                              })
                              error_count += 1
                  else:
                      skipped_count += 1

              # Summary
              print("\n" + "=" * 60)
              print(f"üìä CLEANUP SUMMARY")
              print(f"Mode: {'DRY RUN' if dry_run else 'LIVE EXECUTION'}")
              print(f"Criteria: {criteria}")
              print(f"‚úÖ {'Would complete' if dry_run else 'Completed'}: {completed_count}")
              print(f"‚è≠Ô∏è  Skipped: {skipped_count}")
              print(f"‚ùå Errors: {error_count}")
              print(f"üìÖ Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}")

              # Set outputs for GitHub Actions
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"completed_count={completed_count}\n")
                  f.write(f"skipped_count={skipped_count}\n")
                  f.write(f"error_count={error_count}\n")

              # Save detailed log
              log_data = {
                  "timestamp": datetime.now().isoformat(),
                  "mode": "dry_run" if dry_run else "live",
                  "criteria": criteria,
                  "summary": {
                      "completed": completed_count,
                      "skipped": skipped_count,
                      "errors": error_count
                  },
                  "details": completion_log
              }

              with open('cleanup_log.json', 'w') as f:
                  json.dump(log_data, f, indent=2)

              return True

          if __name__ == "__main__":
              success = run_cleanup()
              sys.exit(0 if success else 1)
          EOF

          # Set environment variables
          export ASANA_PAT="${{ secrets.ASANA_PAT }}"
          export DRY_RUN="${{ github.event.inputs.dry_run || 'true' }}"
          export COMPLETION_CRITERIA="${{ github.event.inputs.completion_criteria || 'overdue' }}"

          python scheduled_cleanup.py

      - name: Upload Cleanup Log
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: cleanup-log-${{ github.run_number }}
          path: cleanup_log.json
          retention-days: 30

      - name: Generate Summary Report
        id: summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          ## üßπ Scheduled Asana Cleanup Report

          **Execution Time:** $(date -u)
          **Mode:** ${{ github.event.inputs.dry_run == 'true' && 'DRY RUN' || 'LIVE EXECUTION' }}
          **Criteria:** ${{ github.event.inputs.completion_criteria || 'overdue' }}

          ### Results Summary
          - ‚úÖ **${{ steps.cleanup.outputs.completed_count }}** tasks ${{ github.event.inputs.dry_run == 'true' && 'would be completed' || 'completed' }}
          - ‚è≠Ô∏è **${{ steps.cleanup.outputs.skipped_count }}** tasks skipped
          - ‚ùå **${{ steps.cleanup.outputs.error_count }}** errors encountered

          ### Completion Criteria
          - **overdue**: Tasks past their due date
          - **ready_tag**: Tasks tagged with 'ready-for-completion'
          - **old_completed_subtasks**: Tasks with all subtasks completed

          ### Next Steps
          ${{ github.event.inputs.dry_run == 'true' && '- Review the results and run in live mode if satisfied' || '- Check Asana to verify task completions' }}
          - Review the detailed log artifact for complete information
          - Adjust criteria if needed for future runs
          EOF

  notify-results:
    needs: scheduled-cleanup
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Prepare Notification Message
        id: message
        run: |
          if [ "${{ github.event.inputs.dry_run }}" == "false" ] || [ "${{ github.event_name }}" == "schedule" ]; then
            MODE="üî¥ LIVE EXECUTION"
          else
            MODE="üü° DRY RUN"
          fi

          MESSAGE="Asana Cleanup $MODE Complete
          ‚úÖ ${{ needs.scheduled-cleanup.outputs.completed_count }} tasks processed
          ‚è≠Ô∏è ${{ needs.scheduled-cleanup.outputs.skipped_count }} tasks skipped
          ‚ùå ${{ needs.scheduled-cleanup.outputs.error_count }} errors

          Criteria: ${{ github.event.inputs.completion_criteria || 'overdue' }}
          Repository: ${{ github.repository }}
          Time: $(date -u)"

          echo "message<<EOF" >> $GITHUB_OUTPUT
          echo "$MESSAGE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Uncomment and configure these steps when you're ready to add notifications

      # - name: Notify Slack
      #   if: env.SLACK_WEBHOOK_URL != ''
      #   uses: 8398a7/action-slack@v3
      #   with:
      #     status: ${{ job.status }}
      #     text: ${{ steps.message.outputs.message }}
      #   env:
      #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      # - name: Notify Teams
      #   if: env.TEAMS_WEBHOOK_URL != ''
      #   uses: aliencube/microsoft-teams-actions@v0.8.0
      #   with:
      #     webhook_uri: ${{ secrets.TEAMS_WEBHOOK_URL }}
      #     title: "Asana Cleanup Report"
      #     text: ${{ steps.message.outputs.message }}

      - name: Create Issue on Errors
        if: needs.scheduled-cleanup.outputs.error_count > 0
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üö® Asana Cleanup Errors - ${new Date().toISOString().split('T')[0]}`,
              body: `## Scheduled Cleanup Encountered Errors

              **Date:** ${new Date().toISOString()}
              **Workflow Run:** ${context.runId}
              **Errors:** ${{ needs.scheduled-cleanup.outputs.error_count }}

              ### Summary
              - ‚úÖ Completed: ${{ needs.scheduled-cleanup.outputs.completed_count }}
              - ‚è≠Ô∏è Skipped: ${{ needs.scheduled-cleanup.outputs.skipped_count }}
              - ‚ùå Errors: ${{ needs.scheduled-cleanup.outputs.error_count }}

              ### Action Required
              Please review the workflow logs and cleanup log artifact to identify and resolve the errors.

              **Workflow URL:** ${context.payload.repository.html_url}/actions/runs/${context.runId}`,
              labels: ['bug', 'automation', 'asana-integration']
            });
