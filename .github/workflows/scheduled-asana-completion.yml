# Corrected Workflow: Scheduled Asana Completion
# This workflow automatically completes Asana tasks based on defined criteria.
# It combines the robust inline script from the cleanup workflow with the improved
# notification logic from the original completion workflow.

name: Scheduled Asana Completion

on:
  schedule:
    # Run daily at 9 AM UTC
    - cron: '0 9 * * *'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run in dry-run mode (true/false)'
        required: false
        default: 'true'
        type: boolean
      completion_criteria:
        description: 'Which tasks to complete'
        required: false
        default: 'overdue'
        type: choice
        options:
          - overdue
          - ready_tag
          - old_completed_subtasks
      send_notifications:
        description: 'Send Slack/Teams notifications (true/false)'
        required: false
        default: 'true'
        type: boolean

jobs:
  run-completion:
    runs-on: ubuntu-latest
    outputs:
      completed-count: ${{ steps.cleanup.outputs.completed_count }}
      skipped-count: ${{ steps.cleanup.outputs.skipped_count }}
      error-count: ${{ steps.cleanup.outputs.error_count }}
      criteria: ${{ github.event.inputs.completion_criteria || 'overdue' }}
      dry-run: ${{ github.event.inputs.dry_run || 'true' }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Python 3.9
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install Python Dependencies
        run: pip install asana python-dateutil requests

      - name: Run Asana Completion Script
        id: cleanup
        env:
          ASANA_PAT: ${{ secrets.ASANA_PAT }}
          DRY_RUN: ${{ github.event.inputs.dry_run || 'true' }}
          COMPLETION_CRITERIA: ${{ github.event.inputs.completion_criteria || 'overdue' }}
        run: |
          cat > scheduled_cleanup.py << 'EOF'
          import asana
          import sys
          import os
          from datetime import datetime, timedelta
          from dateutil import parser
          import json

          def get_client():
              pat = os.getenv('ASANA_PAT')
              if not pat:
                  print("âŒ ASANA_PAT not found")
                  return None
              return asana.Client.access_token(pat)

          def is_overdue_task(task):
              if not task.get('due_date'): return False
              due_date = parser.parse(task['due_date']).date()
              return due_date < datetime.now().date()

          def has_ready_tag(task, client):
              try:
                  task_details = client.tasks.find_by_id(task['gid'], {"opt_fields": "tags.name"})
                  tags = [tag['name'].lower() for tag in task_details.get('tags', [])]
                  return any('ready' in tag or 'complete' in tag for tag in tags)
              except: return False

          def has_completed_subtasks(task, client):
              try:
                  subtasks = list(client.tasks.subtasks(task['gid'], {"opt_fields": "completed"}))
                  if not subtasks: return False
                  return all(st['completed'] for st in subtasks)
              except: return False

          def should_complete_task(task, criteria, client):
              if task['completed']: return False, "Already completed"
              if criteria == 'overdue':
                  if is_overdue_task(task): return True, "Overdue task"
              elif criteria == 'ready_tag':
                  if has_ready_tag(task, client): return True, "Has ready tag"
              elif criteria == 'old_completed_subtasks':
                  if has_completed_subtasks(task, client): return True, "All subtasks completed"
              return False, "Does not meet criteria"

          def run_cleanup():
              dry_run = os.getenv('DRY_RUN', 'true').lower() == 'true'
              criteria = os.getenv('COMPLETION_CRITERIA', 'overdue')
              print(f"ðŸ” Running {'DRY RUN' if dry_run else 'LIVE'} cleanup with criteria: {criteria}")
              client = get_client()
              if not client: sys.exit(1)

              workspaces = list(client.workspaces.find_all())
              if not workspaces:
                  print("âŒ No workspaces found")
                  sys.exit(1)
              workspace_id = workspaces[0]['gid']

              me = client.users.me()
              tasks = list(client.tasks.find_by_user(me['gid'], {
                  "workspace": workspace_id,
                  "opt_fields": "name,completed,due_date,projects.name,assignee.name",
                  "completed_since": "now"
              }))

              completed_count, skipped_count, error_count = 0, 0, 0
              completion_log = []

              for task in tasks:
                  should, reason = should_complete_task(task, criteria, client)
                  if should:
                      if dry_run:
                          print(f"ðŸ” WOULD COMPLETE: {task['name']} (Reason: {reason})")
                          completion_log.append({"task": task['name'], "action": "would_complete", "reason": reason})
                          completed_count += 1
                      else:
                          try:
                              client.tasks.update(task['gid'], {'completed': True})
                              print(f"âœ… COMPLETED: {task['name']} (Reason: {reason})")
                              completion_log.append({"task": task['name'], "action": "completed", "reason": reason})
                              completed_count += 1
                          except Exception as e:
                              print(f"âŒ ERROR completing {task['name']}: {e}")
                              completion_log.append({"task": task['name'], "action": "error", "error": str(e)})
                              error_count += 1
                  else:
                      skipped_count += 1

              print(f"\nðŸ“Š Summary: Completed: {completed_count}, Skipped: {skipped_count}, Errors: {error_count}")

              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write(f"completed_count={completed_count}\n")
                  f.write(f"skipped_count={skipped_count}\n")
                  f.write(f"error_count={error_count}\n")

              with open('cleanup_log.json', 'w') as f:
                  json.dump({"details": completion_log}, f, indent=2)

          if __name__ == "__main__":
              run_cleanup()
          EOF

          python scheduled_cleanup.py

      - name: Upload Cleanup Log
        uses: actions/upload-artifact@v4
        with:
          name: completion-results-${{ github.run_number }}
          path: cleanup_log.json

      - name: Generate Job Summary
        run: |
          COMPLETED=${{ steps.cleanup.outputs.completed_count }}
          SKIPPED=${{ steps.cleanup.outputs.skipped_count }}
          CRITERIA="${{ github.event.inputs.completion_criteria || 'overdue' }}"
          DRY_RUN_MODE="${{ github.event.inputs.dry_run || 'true' }}"
          
          ACTION_TEXT="Completed"
          if [[ "$DRY_RUN_MODE" == "true" ]]; then
            ACTION_TEXT="Would Complete"
          fi

          echo "## ðŸ“Š Asana Completion Report" >> $GITHUB_STEP_SUMMARY
          echo "**Criteria:** \`$CRITERIA\`" >> $GITHUB_STEP_SUMMARY
          echo "**Mode:** $(if [[ "$DRY_RUN_MODE" == "true" ]]; then echo 'Dry Run'; else echo 'Live Run'; fi)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… **$ACTION_TEXT:** $COMPLETED tasks" >> $GITHUB_STEP_SUMMARY
          echo "- â­ï¸ **Skipped:** $SKIPPED tasks" >> $GITHUB_STEP_SUMMARY

  notify:
    needs: run-completion
    if: always() && (github.event.inputs.send_notifications == 'true' || (github.event_name == 'schedule' && github.event.inputs.send_notifications != 'false'))
    runs-on: ubuntu-latest
    steps:
      - name: Send Slack Notification
        if: secrets.SLACK_WEBHOOK_URL
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "text": "ðŸ¤– Asana Scheduled Completion Report",
              "blocks": [
                { "type": "header", "text": { "type": "plain_text", "text": "ðŸ“Š Asana Completion Report" } },
                { "type": "section", "fields": [
                    { "type": "mrkdwn", "text": "*Criteria:*\n`${{ needs.run-completion.outputs.criteria }}`" },
                    { "type": "mrkdwn", "text": "*Mode:*\n${{ needs.run-completion.outputs.dry-run == 'true' ? 'Dry Run' : 'Live Run' }}" }
                  ]
                },
                { "type": "section", "fields": [
                    { "type": "mrkdwn", "text": "*âœ… ${{ needs.run-completion.outputs.dry-run == 'true' ? 'Would Complete' : 'Completed' }}:*\n${{ needs.run-completion.outputs.completed-count }} tasks" },
                    { "type": "mrkdwn", "text": "*â­ï¸ Skipped:*\n${{ needs.run-completion.outputs.skipped-count }} tasks" }
                  ]
                },
                { "type": "section", "fields": [
                    { "type": "mrkdwn", "text": "*âŒ Errors:*\n${{ needs.run-completion.outputs.error-count }} tasks" }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create Issue on Errors
        if: needs.run-completion.outputs.error-count > 0
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸš¨ Asana Cleanup Errors - ${new Date().toISOString().split('T')[0]}`,
              body: `## Scheduled Cleanup Encountered Errors

              **Date:** ${new Date().toISOString()}
              **Workflow Run:** ${context.runId}
              **Errors:** ${{ needs.run-completion.outputs.error-count }}

              Please review the workflow logs and the \`completion-results-${context.runId}\` artifact to identify and resolve the errors.

              **Workflow URL:** ${context.payload.repository.html_url}/actions/runs/${context.runId}`,
              labels: ['bug', 'automation', 'asana-integration']
            });